use crate::syntax::*;
use std::cell::RefCell;
use std::collections::HashMap;
use std::ptr::NonNull;

// XXX this should be a reference type automatically generated by syntax.rs
#[derive(Copy, Clone)]
pub enum DeclRef {
    BuiltinFunction,
    Class(NonNull<ClassDeclaration>),
    Function,
    Parameter,
    Variable,
}

impl DeclRef {
    pub fn into_class_decl<'a>(&self) -> Option<&'a ClassDeclaration> {
        match &self {
            // SAFETY: the AST outlives the SymbolTable
            Self::Class(ptr) => Some(unsafe { &ptr.as_ref() }),
            _ => None,
        }
    }
}

#[derive(Clone)]
struct SymbolTableEntry {
    decl: DeclRef,
    scope_distance: usize,
}

#[derive(Eq, Hash, PartialEq)]
enum Symbol {
    Subclass(NonNull<ClassDeclaration>),
    Super(NonNull<SuperExpression>),
    This(NonNull<ThisExpression>),
    Variable(NonNull<Variable>),
}

impl Symbol {
    pub fn from_super(super_: &SuperExpression) -> Self {
        Self::Super(NonNull::from(super_))
    }

    pub fn from_subclass(subclass: &ClassDeclaration) -> Self {
        Self::Subclass(NonNull::from(subclass))
    }

    pub fn from_this(this: &ThisExpression) -> Self {
        Self::This(NonNull::from(this))
    }

    pub fn from_variable(var: &Variable) -> Self {
        Self::Variable(NonNull::from(var))
    }

    pub fn name(&self) -> &str {
        match self {
            Symbol::Subclass(subclass) => unsafe { &subclass.as_ref().name.lexeme},
            Symbol::Super(_) => "super",
            Symbol::This(_) => "this",
            Symbol::Variable(var) => unsafe { &var.as_ref().name.lexeme},
        }
    }
}

pub struct SymbolTable {
    symbols: RefCell<HashMap<Symbol, SymbolTableEntry>>,
}

impl SymbolTable {
    pub fn new() -> Self {
        Self { 
            symbols: RefCell::new(HashMap::new()),
        }
    }

    pub fn insert_superclass(&self, subclass: &ClassDeclaration, superclass: &ClassDeclaration, scope_distance: usize) {
        let entry = SymbolTableEntry{ decl: DeclRef::Class(NonNull::from(superclass)), scope_distance };
        self.symbols
            .borrow_mut()
            .insert(Symbol::Subclass(NonNull::from(subclass)), entry);
    }

    pub fn insert_super(&self, super_: &SuperExpression, decl: &ClassDeclaration, scope_distance: usize) {
        let entry = SymbolTableEntry{ decl: DeclRef::Class(NonNull::from(decl)), scope_distance };
        self.symbols
            .borrow_mut()
            .insert(Symbol::Super(NonNull::from(super_)), entry);
    }

    pub fn insert_this(&self, this: &ThisExpression, decl: &ClassDeclaration, scope_distance: usize) {
        let entry = SymbolTableEntry { decl: DeclRef::Class(NonNull::from(decl)), scope_distance };
        self.symbols
            .borrow_mut()
            .insert(Symbol::This(NonNull::from(this)), entry);
    }

    pub fn insert_variable(&self, var: &Variable, decl: DeclRef, scope_distance: usize) {
        let entry = SymbolTableEntry { decl, scope_distance };
        self.symbols
            .borrow_mut()
            .insert(Symbol::Variable(NonNull::from(var)), entry);
    }

    fn get(&self, symbol: Symbol) -> Result<SymbolTableEntry, String> {
        self.symbols
            .borrow()
            .get(&symbol)
            .cloned()
            .ok_or(format!("Internal error: '{}' was not found in symbol table", symbol.name()))
    }

    pub fn get_superclass(&self, subclass: &ClassDeclaration) -> Result<(&ClassDeclaration, usize), String> {
        let entry = self.get(Symbol::from_subclass(subclass))?;
        let class_decl = entry.decl.into_class_decl()
            .ok_or("Internal error: super class mapped to non-class declaration")?;
        Ok((class_decl, entry.scope_distance))
    }

    pub fn get_super(&self, super_: &SuperExpression) -> Result<(&ClassDeclaration, usize), String> {
        let entry = self.get(Symbol::from_super(super_))?;
        let class_decl = entry.decl.into_class_decl()
            .ok_or("Internal error: super expression mapped to non-class declaration")?;
        Ok((class_decl, entry.scope_distance))
    }

    pub fn get_this(&self, this: &ThisExpression) -> Result<(&ClassDeclaration, usize), String> {
        let entry = self.get(Symbol::from_this(this))?;
        let class_decl = entry.decl.into_class_decl()
            .ok_or("Internal error: this expression mapped to non-class declaration")?;
        Ok((class_decl, entry.scope_distance))
    }

    pub fn get_variable(&self, var: &Variable) -> Result<(DeclRef, usize), String> {
        let entry = self.get(Symbol::from_variable(var))?;
        Ok((entry.decl, entry.scope_distance))
    }
}
